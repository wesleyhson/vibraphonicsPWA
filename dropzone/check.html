<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VibraTronix â€” Cosmic Ascend</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;}
    canvas{display:block;width:100%;height:100%;}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
  // === GLOBALS ===
  let isPlaying = false;
  let kickLoop, melodyLoop;
  let kickPulse = 0;
  let stars = [], nebula = [];
  let nebulaPulse = 0;
  let pistons = [];
  let blessings = [];
  let bars = [];
  let heights = new Array(8).fill(0);
  let targets = new Array(8).fill(0);
  let scaleOffset = 0;
  let scaleDirection = 1;
  let scaleTimer = 0;
  let animationId = null;

  // === CANVAS ===
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // === SPACE BACKGROUND ===
  function initSpace() {
    stars = Array.from({length: 450}, () => ({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: Math.random() * 2,
      twinkle: Math.random() * Math.PI * 2,
      speed: 0.08 + Math.random() * 0.25
    }));
    nebula = Array.from({length: 7}, () => ({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: 320 + Math.random() * 500,
      baseR: 320 + Math.random() * 500,
      color: ['#4a148c','#6a1b9a','#7b1fa2','#8e24aa'][~~(Math.random()*4)],
      vx: (Math.random() - 0.5) * 0.25,
      vy: (Math.random() - 0.5) * 0.25
    }));
  }

  function drawSpace() {
    nebulaPulse = kickPulse * 0.8 + nebulaPulse * 0.2;
    nebula.forEach(n => {
      n.x += n.vx; n.y += n.vy;
      if (n.x < -n.r) n.x = innerWidth + n.r;
      if (n.x > innerWidth + n.r) n.x = -n.r;
      if (n.y < -n.r) n.y = innerHeight + n.r;
      if (n.y > innerHeight + n.r) n.y = -n.r;
      const pulseR = n.baseR * (1 + nebulaPulse * 0.3);
      const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, pulseR);
      g.addColorStop(0, n.color + '28');
      g.addColorStop(0.7, n.color + '11');
      g.addColorStop(1, 'transparent');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(n.x, n.y, pulseR, 0, Math.PI*2);
      ctx.fill();
    });

    stars.forEach(s => {
      s.x += s.speed;
      if (s.x > innerWidth) s.x = 0;
      const t = Math.sin(Date.now()*0.001 + s.twinkle)*0.5 + 0.5;
      const pulse = 1 + nebulaPulse * 0.5;
      ctx.fillStyle = `rgba(255,255,255,${t})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r * pulse, 0, Math.PI*2);
      ctx.fill();
    });
  }

  // === NEON BARS ===
  const barCount = 8;
  const barWidth = 36;
  const barSpacing = 80;
  const colors = ['#ff004d','#ff6600','#ffcc00','#00ff66','#00ccff','#0066ff','#cc00ff','#ffffff'];
  const rootNotes = ['C3','D3','E3','G3','A3','C4','D4','E4'];

  // === TONE.JS SETUP ===
  const synths = [];
  for (let i = 0; i < barCount; i++) {
    const s = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "sine" },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.4 }
    }).toDestination();
    s.volume.value = -18;
    synths.push(s);
  }

  const kick = new Tone.MembraneSynth({
    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }
  }).toDestination();
  kick.volume.value = -10;

  // === LOOPS ===
  kickLoop = new Tone.Loop(t => {
    kick.triggerAttackRelease("C1", "8n", t);
    kickPulse = 1;
  }, "4n");

  melodyLoop = new Tone.Loop(t => {
    const i = Math.floor(Math.random() * barCount);
    synths[i].triggerAttackRelease(Tone.Midi(rootNotes[(i + scaleOffset) % rootNotes.length]).toFrequency(), "16n", t);
    targets[i] = 1;
  }, "8n");

  // === ASCENDING SCALE ===
  function updateScale() {
    scaleTimer += 1;
    if (scaleTimer % 24 === 0) {
      scaleOffset = (scaleOffset + scaleDirection + rootNotes.length) % rootNotes.length;
      if (scaleOffset === 0 || scaleOffset === rootNotes.length - 1) {
        scaleDirection *= -1;
      }
    }
  }

  // === DRAW BARS ===
  function drawBars() {
    const startX = (canvas.width - barCount * barSpacing) / 2 + 40;
    for (let i = 0; i < barCount; i++) {
      const x = startX + i * barSpacing;
      const maxH = canvas.height * 0.78;
      const h = maxH * heights[i] * (1 + kickPulse * 3);

      const g = ctx.createLinearGradient(x, canvas.height, x, canvas.height - h);
      g.addColorStop(0, 'transparent');
      g.addColorStop(0.4, colors[i] + 'bb');
      g.addColorStop(1, colors[i]);
      ctx.fillStyle = g;
      ctx.shadowBlur = 45 + kickPulse * 90;
      ctx.shadowColor = colors[i];
      ctx.fillRect(x - barWidth/2, canvas.height - h, barWidth, h);

      ctx.fillStyle = colors[i];
      ctx.shadowBlur = 18;
      ctx.fillRect(x - 2, canvas.height - h, 4, h);
    }
    ctx.shadowBlur = 0;
  }

  // === UPDATE BARS ===
  function updateBars() {
    kickPulse *= 0.84;
    for (let i = 0; i < barCount; i++) {
      heights[i] += (targets[i] - heights[i]) * 0.24;
      if (heights[i] < 0.01) heights[i] = 0;
      targets[i] *= 0.92;
    }
  }

  // === ANIMATION LOOP ===
  function animate() {
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawSpace();
    updateBars();
    drawBars();
    updateScale();
    animationId = requestAnimationFrame(animate);
  }

  // === START / PAUSE ===
  async function start() {
    if (isPlaying) return;
    await Tone.start();  // RESTORED
    kickLoop.start(0);
    melodyLoop.start(0);
    initSpace();
    animationId = requestAnimationFrame(animate);
    isPlaying = true;
  }

  function pause() {
    if (!isPlaying) return;
    kickLoop.stop();
    melodyLoop.stop();
    if (animationId) cancelAnimationFrame(animationId);
    isPlaying = false;
  }

  // === LISTEN FOR CONTROL ===
  window.addEventListener('message', (e) => {
    if (e.data.action === 'unlocked') start();
    if (e.data.action === 'play' && !isPlaying) start();
    if (e.data.action === 'pause' && isPlaying) pause();
    if (e.data.action === 'tabHidden') pause();
    if (e.data.action === 'tabVisible' && isPlaying) start();
  });

  // === AUTO-START AFTER UNLOCK ===
  const check = setInterval(() => {
    if (window.top && window.top.audioUnlocked) {
      clearInterval(check);
      start();
    }
  }, 100);
</script>
</body>
</html>