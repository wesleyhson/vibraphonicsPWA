<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VibraTronix â€” Cosmic Orb Choir</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body, html { background:#000; overflow:hidden; width:100%; height:100%; }
    canvas { display:block; width:100%; height:100%; image-rendering:pixelated; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false }); // Faster
    let audioCtx, masterGain, reverb;
    let stars = [], nebula = [];
    let visualOrbs = [], musicOrbs = [];
    let step = 0;
    let animationId = null;
    let musicInterval = null;
    let isPlaying = false;
    let lastTime = 0;

    // === RESIZE ===
    function resize() {
      canvas.width = innerWidth * 0.8;  // Lower res = faster
      canvas.height = innerHeight * 0.8;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    }
    window.addEventListener('resize', resize);
    resize();

    // === AUDIO SETUP ===
    async function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 1.0;
      reverb = audioCtx.createConvolver();
      const impulse = createCosmicReverb();
      reverb.buffer = impulse;
      masterGain.connect(reverb).connect(audioCtx.destination);
    }

    function createCosmicReverb() {
      const length = audioCtx.sampleRate * 1.8; // Shorter = faster
      const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
      const left = impulse.getChannelData(0);
      const right = impulse.getChannelData(1);
      for (let i = 0; i < length; i++) {
        const decay = Math.exp(-i / (audioCtx.sampleRate * 0.6));
        left[i] = (Math.random() * 2 - 1) * decay * 0.2;
        right[i] = (Math.random() * 2 - 1) * decay * 0.2;
      }
      return impulse;
    }

    // === SPAWN ORBS (REDUCED) ===
    function spawnVisualOrbs(count) {
      visualOrbs = [];
      for (let i = 0; i < count; i++) {
        visualOrbs.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: 2 + Math.random() * 3,  // Smaller
          vx: (Math.random() - 0.5) * 1.5,
          vy: (Math.random() - 0.5) * 1.5,
          color: ['#ff6b6b','#f9ca24','#1dd1a1','#48dbfb','#ff9ff3'][i%5],
          pulse: 0
        });
      }
    }

    function spawnMusicOrbs() {
      musicOrbs = [];
      const instruments = [
        { note: 60, color: '#ff6b6b' },
        { note: 64, color: '#f9ca24' },
        { note: 67, color: '#1dd1a1' },
        { note: 70, color: '#48dbfb' },
        { note: 62, color: '#ff9ff3' },
        { note: 48, color: '#ffffff' }
      ];
      instruments.forEach((inst, i) => {
        musicOrbs.push({
          x: canvas.width * (0.2 + i * 0.12),
          y: canvas.height * 0.5,
          r: 60,  // Smaller
          pulse: 0,
          color: inst.color,
          note: inst.note
        });
      });
    }

    // === PLAY NOTE (SIMPLIFIED) ===
    function playOrbNote(orb) {
      const t = audioCtx.currentTime;
      const freq = 440 * Math.pow(2, (orb.note - 69) / 12);
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 2);
      osc.connect(gain).connect(masterGain);
      osc.start(t); osc.stop(t + 2);
      orb.pulse = 1.5;
    }

    // === MUSIC LOOP (LESS FREQUENT) ===
    function musicStep() {
      step = (step + 1) % 16;
      const pattern = [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0]; // Slower
      if (pattern[step]) {
        const orb = musicOrbs[Math.floor(Math.random() * musicOrbs.length)];
        playOrbNote(orb);
      }
      musicOrbs.forEach(o => o.pulse *= 0.9);
    }

    // === SPACE (FEWER STARS/NEBULA) ===
    function initSpace() {
      stars = [];
      for (let i = 0; i < 100; i++) {  // Was 300
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 1,
          twinkle: Math.random() * Math.PI * 2
        });
      }
      nebula = [];
      for (let i = 0; i < 4; i++) {  // Was 8
        nebula.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: 150 + Math.random() * 200,
          color: ['#4a148c','#6a1b9a','#7b1fa2','#8e24aa'][i]
        });
      }
    }

    function drawSpace() {
      nebula.forEach(n => {
        const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
        gradient.addColorStop(0, n.color + '18');
        gradient.addColorStop(1, n.color + '00');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height); // Batch
      });
      stars.forEach(s => {
        const twinkle = Math.sin(Date.now() * 0.001 + s.twinkle) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${twinkle*0.8})`;
        ctx.fillRect(s.x, s.y, s.r, s.r);
      });
    }

    // === COLLISIONS (SKIP EVERY OTHER FRAME) ===
    let collisionFrame = 0;
    function checkVisualCollisions() {
      if (collisionFrame++ % 2 !== 0) return; // 30 FPS
      for (let i = 0; i < visualOrbs.length; i++) {
        for (let j = i + 1; j < visualOrbs.length; j++) {
          const a = visualOrbs[i], b = visualOrbs[j];
          const dist = Math.hypot(a.x - b.x, a.y - b.y);
          if (dist < a.r + b.r) {
            a.r += 0.4; b.r += 0.4;
            if (a.r > 40 || b.r > 40) {
              const winner = a.r > b.r ? a : b;
              const loser = a.r > b.r ? b : a;
              winner.r += loser.r * 0.6;
              visualOrbs.splice(visualOrbs.indexOf(loser), 1);
            }
          }
        }
      }
    }

    // === DRAW ORB (SIMPLIFIED) ===
    function drawOrb(orb) {
      ctx.fillStyle = orb.color;
      ctx.shadowBlur = 60 + orb.pulse * 120;
      ctx.shadowColor = orb.color;
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, orb.r * (1 + orb.pulse), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // === ANIMATION LOOP (60 FPS, OPTIMIZED) ===
    function animate(time) {
      if (!lastTime) lastTime = time;
      const delta = time - lastTime;
      if (delta < 16) { animationId = requestAnimationFrame(animate); return; } // Cap 60 FPS
      lastTime = time;

      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawSpace();

      visualOrbs.forEach(orb => {
        orb.vx += (Math.random() - 0.5) * 0.2;
        orb.vy += (Math.random() - 0.5) * 0.2;
        orb.vx *= 0.98; orb.vy *= 0.98;
        orb.x += orb.vx; orb.y += orb.vy;
        orb.pulse *= 0.92;
        if (orb.x < orb.r) { orb.x = orb.r; orb.vx *= -0.6; }
        if (orb.x > canvas.width - orb.r) { orb.x = canvas.width - orb.r; orb.vx *= -0.6; }
        if (orb.y < orb.r) { orb.y = orb.r; orb.vy *= -0.6; }
        if (orb.y > canvas.height - orb.r) { orb.y = canvas.height - orb.r; orb.vy *= -0.6; }
      });

      checkVisualCollisions();
      visualOrbs.forEach(drawOrb);
      musicOrbs.forEach(drawOrb);

      animationId = requestAnimationFrame(animate);
    }

    // === START / PAUSE ===
    async function start() {
      if (isPlaying) return;
      await initAudio();
      initSpace();
      spawnVisualOrbs(150);  // Was 500
      spawnMusicOrbs();
      musicInterval = setInterval(musicStep, 500); // Slower
      lastTime = 0;
      animate();
      isPlaying = true;
    }

    function pause() {
      if (!isPlaying) return;
      clearInterval(musicInterval);
      if (animationId) cancelAnimationFrame(animationId);
      isPlaying = false;
    }

    // === LISTEN FOR UNLOCK + PLAY/PAUSE ===
    window.addEventListener('message', (e) => {
      if (e.data.action === 'unlocked') start();
      if (e.data.action === 'play' && !isPlaying) start();
      if (e.data.action === 'pause' && isPlaying) pause();
    });

    // === AUTO-START IF UNLOCKED LATER ===
    const check = setInterval(() => {
      if (window.top && window.top.audioUnlocked) {
        clearInterval(check);
        start();
      }
    }, 100);
  </script>
</body>
</html>