<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COSMIC PISTON BLESSINGS</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;}
    canvas{display:block;width:100%;height:100%;}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // === ORIGINAL DEEP SPACE BACKGROUND ===
  let stars = [], nebula = [];
  function initSpace() {
    stars = Array.from({length: 400}, () => ({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: Math.random() * 1.8,
      twinkle: Math.random() * Math.PI * 2,
      speed: 0.1 + Math.random() * 0.3
    }));
    nebula = Array.from({length: 6}, () => ({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: 300 + Math.random() * 400,
      color: ['#4a148c','#6a1b9a','#7b1fa2','#8e24aa'][~~(Math.random()*4)],
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.3
    }));
  }

  function drawSpace() {
    nebula.forEach(n => {
      n.x += n.vx; n.y += n.vy;
      if (n.x < -n.r) n.x = innerWidth + n.r;
      if (n.x > innerWidth + n.r) n.x = -n.r;
      if (n.y < -n.r) n.y = innerHeight + n.r;
      if (n.y > innerHeight + n.r) n.y = -n.r;
      const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
      g.addColorStop(0, n.color + '18');
      g.addColorStop(1, n.color + '00');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
      ctx.fill();
    });

    stars.forEach(s => {
      s.x += s.speed;
      if (s.x > innerWidth) s.x = 0;
      const t = Math.sin(Date.now()*0.001 + s.twinkle)*0.5 + 0.5;
      ctx.fillStyle = `rgba(255,255,255,${t})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    });
  }

  // === SCALE-MOVING BARS (C3 â†’ E4) ===
  const barCount = 8;
  const barWidth = 36;
  const barSpacing = 76;
  let startX = 0;
  const colors = ['#ff004d','#ff6600','#ffcc00','#00ff66','#00ccff','#0066ff','#cc00ff','#ffffff'];
  const baseNotes = ['C3','D3','E3','G3','A3','C4','D4','E4'];
  let currentScale = [...baseNotes];
  let scaleDirection = 1;
  let scaleIndex = 0;

  const heights = new Array(barCount).fill(0);
  const targets = new Array(barCount).fill(0);
  let kickPulse = 0;

  // === TONE.JS ===
  const synths = [];
  for (let i = 0; i < barCount; i++) {
    const s = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "sine" },
      envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 }
    }).toDestination();
    s.volume.value = -14;
    synths.push(s);
  }

  const kick = new Tone.MembraneSynth({
    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }
  }).toDestination();

  const kickLoop = new Tone.Loop(t => {
    kick.triggerAttackRelease("C1", "8n", t);
    kickPulse = 1.8;
    // Flash screen
    document.body.style.filter = 'brightness(1.3)';
    setTimeout(() => document.body.style.filter = '', 80, 80);
  }, "4n");

  const melodyLoop = new Tone.Loop(t => {
    const i = ~~(Math.random() * barCount);
    synths[i].triggerAttackRelease(currentScale[i], "8n", t);
    targets[i] = 1;
    firePiston(i);
  }, "2n");

  const analyser = new Tone.Analyser("waveform", 32);
  kick.connect(analyser);

  // === MAGIC PISTONS & BLESSINGS ===
  let pistons = [];
  let blessings = [];

  function firePiston(barIndex) {
    const x = startX + barIndex * barSpacing;
    const y = innerHeight;
    const h = innerHeight * 0.75 * heights[barIndex];
    pistons.push({
      x, y: y - h, targetY: 0, progress: 0,
      color: colors[barIndex], barIndex
    });
  }

  function updatePistons() {
    pistons = pistons.filter(p => {
      p.progress += 0.04;
      p.y = innerHeight - (innerHeight * 0.75 * heights[p.barIndex]) * (1 - p.progress) + p.targetY * p.progress;
      if (p.progress >= 1) {
        explodeBlessings(p.x, p.y, p.color);
        return false;
      }
      return true;
    });
  }

  function explodeBlessings(x, y, color) {
    for (let i = 0; i < 40; i++) {
      const angle = (Math.PI * 2 * i) / 40;
      const speed = 6 + Math.random() * 10;
      blessings.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: 2 + Math.random() * 4,
        life: 1,
        color: i % 3 === 0 ? '#ffd700' : color
      });
    }
  }

  function drawBlessings() {
    blessings = blessings.filter(b => {
      b.x += b.vx; b.y += b.vy; b.vy += 0.4;
      b.vx *= 0.96; b.life *= 0.88; b.r *= 0.93;
      ctx.fillStyle = b.color + (~~(b.life * 255)).toString(16).padStart(2, '0');
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      return b.life > 0.05;
    });
  }

  function drawPistons() {
    pistons.forEach(p => {
      const h = innerHeight - p.y;
      const g = ctx.createLinearGradient(p.x, innerHeight, p.x, p.y);
      g.addColorStop(0, 'transparent');
      g.addColorStop(0.6, p.color + 'cc');
      g.addColorStop(1, p.color);
      ctx.fillStyle = g;
      ctx.shadowBlur = 60;
      ctx.shadowColor = p.color;
      ctx.fillRect(p.x - barWidth/2, p.y, barWidth, h);
    });
    ctx.shadowBlur = 0;
  }

  // === SCALE MOVEMENT (UP & DOWN) ===
  setInterval(() => {
    scaleIndex = (scaleIndex + scaleDirection + baseNotes.length) % baseNotes.length;
    currentScale = baseNotes.map((n, i) => {
      const offset = (i + scaleIndex) % baseNotes.length;
      return baseNotes[offset];
    });
    if (scaleIndex === 0 || scaleIndex === baseNotes.length - 1) scaleDirection *= -1;
  }, 1600);

  // === ANIMATION LOOP ===
  function animate() {
    requestAnimationFrame(animate);
    ctx.fillStyle = 'rgba(0,0,0,0.07)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawSpace();

    kickPulse *= 0.88;

    for (let i = 0; i < barCount; i++) {
      heights[i] += (targets[i] - heights[i]) * 0.22;
      if (heights[i] < 0.01) heights[i] = 0;
      targets[i] *= 0.94;
    }

    startX = (canvas.width - barCount * barSpacing) / 2 + 40;

    // Draw bars
    for (let i = 0; i < barCount; i++) {
      const x = startX + i * barSpacing;
      const maxH = canvas.height * 0.75;
      const h = maxH * heights[i] * (1 + kickPulse * 2.5);

      const g = ctx.createLinearGradient(x, canvas.height, x, canvas.height - h);
      g.addColorStop(0, 'transparent');
      g.addColorStop(0.4, colors[i] + '99');
      g.addColorStop(1, colors[i]);
      ctx.fillStyle = g;
      ctx.shadowBlur = 40 + kickPulse * 80;
      ctx.shadowColor = colors[i];
      ctx.fillRect(x - barWidth/2, canvas.height - h, barWidth, h);

      ctx.fillStyle = colors[i];
      ctx.shadowBlur = 16;
      ctx.fillRect(x - 2, canvas.height - h, 4, h);
    }
    ctx.shadowBlur = 0;

    updatePistons();
    drawPistons();
    drawBlessings();
  }

  // === START ===
  let isPlaying = false;
  async function start() {
    if (isPlaying) return;
    await Tone.start();
    Tone.Transport.bpm.value = 122;
    Tone.Transport.start();
    kickLoop.start(0);
    melodyLoop.start(0);
    initSpace();
    animate();
    isPlaying = true;
  }

  function stop() {
    if (!isPlaying) return;
    Tone.Transport.stop();
    kickLoop.stop();
    melodyLoop.stop();
    isPlaying = false;
  }

  window.addEventListener('message', e => {
    if (e.data.action === 'play') start();
    if (e.data.action === 'pause') stop();
  });

  start();
</script>
</body>
</html>