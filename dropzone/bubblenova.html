<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VibraTronix â€” Eternal Bubble Cosmos</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { background:#000; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<script>
// === LISTEN FOR GLOBAL UNLOCK + PLAY/PAUSE ===
let isPlaying = false;
window.addEventListener('message', (e) => {
  if (e.data.action === 'unlocked') start();
  if (e.data.action === 'play' && !isPlaying) start();
  if (e.data.action === 'pause' && isPlaying) pause();
});

// === GLOBALS ===
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let audioCtx, masterGain, reverb;
let stars = [], nebula = [];
let visualOrbs = [], musicOrbs = [];
let step = 0;
let animationId = null;
let musicInterval = null;

// === RESIZE ===
function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
window.addEventListener('resize', resize);
resize();

// === AUDIO SETUP ===
async function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1.0;
  reverb = audioCtx.createConvolver();
  const impulse = createCosmicReverb();
  reverb.buffer = impulse;
  masterGain.connect(reverb).connect(audioCtx.destination);
}

function createCosmicReverb() {
  const length = audioCtx.sampleRate * 2.5;
  const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
  const left = impulse.getChannelData(0);
  const right = impulse.getChannelData(1);
  for (let i = 0; i < length; i++) {
    const decay = Math.exp(-i / (audioCtx.sampleRate * 0.7));
    left[i] = (Math.random() * 2 - 1) * decay * 0.25;
    right[i] = (Math.random() * 2 - 1) * decay * 0.25;
  }
  return impulse;
}

// === ORB SPAWN ===
function spawnVisualOrbs(count) {
  for (let i = 0; i < count; i++) {
    visualOrbs.push({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: 3 + Math.random() * 5,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2,
      color: ['#ff6b6b','#f9ca24','#1dd1a1','#48dbfb','#ff9ff3'][Math.floor(Math.random()*5)],
      pulse: 0
    });
  }
}

function spawnMusicOrbs() {
  musicOrbs = [];
  const musicInstruments = [
    { note: 60, color: '#ff6b6b' },
    { note: 64, color: '#f9ca24' },
    { note: 67, color: '#1dd1a1' },
    { note: 70, color: '#48dbfb' },
    { note: 62, color: '#ff9ff3' },
    { note: 48, color: '#ffffff' }
  ];
  musicInstruments.forEach((inst, i) => {
    musicOrbs.push({
      x: innerWidth * (0.2 + i * 0.12),
      y: innerHeight * 0.5,
      r: 80,
      pulse: 0,
      color: inst.color,
      note: inst.note
    });
  });
}

// === PLAY NOTE ===
function playOrbNote(orb) {
  const t = audioCtx.currentTime;
  const freq = 440 * Math.pow(2, (orb.note - 69) / 12);
  const carrier = audioCtx.createOscillator();
  const mod = audioCtx.createOscillator();
  const modGain = audioCtx.createGain();
  const outGain = audioCtx.createGain();
  carrier.type = 'sine';
  carrier.frequency.value = freq;
  mod.type = 'sine';
  mod.frequency.value = freq * 3.5;
  modGain.gain.value = freq * 0.18;
  outGain.gain.setValueAtTime(0, t);
  outGain.gain.linearRampToValueAtTime(0.36, t + 0.02);
  outGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5);
  mod.connect(modGain).connect(carrier.frequency);
  carrier.connect(outGain).connect(masterGain);
  carrier.start(t); mod.start(t); carrier.stop(t + 2.5); mod.stop(t + 2.5);
  orb.pulse = 1.8;
}

// === VISUAL COLLISIONS ===
function checkVisualCollisions() {
  for (let i = 0; i < visualOrbs.length; i++) {
    for (let j = i + 1; j < visualOrbs.length; j++) {
      const a = visualOrbs[i], b = visualOrbs[j];
      const dist = Math.hypot(a.x - b.x, a.y - b.y);
      if (dist < a.r + b.r) {
        a.r += 0.6;
        b.r += 0.6;
        a.pulse = 1.4;
        b.pulse = 1.4;
        if (a.r > 55 || b.r > 55) {
          const winner = a.r > b.r ? a : b;
          const loser = a.r > b.r ? b : a;
          winner.r += loser.r * 0.7;
          visualOrbs.splice(visualOrbs.indexOf(loser), 1);
        }
        const angle = Math.atan2(b.y - a.y, b.x - a.x);
        const force = 1.6;
        a.vx -= Math.cos(angle) * force;
        a.vy -= Math.sin(angle) * force;
        b.vx += Math.cos(angle) * force;
        b.vy += Math.sin(angle) * force;
      }
    }
  }
  if (visualOrbs.length <= 1) {
    visualOrbs.forEach(o => o.pulse = 5);
    setTimeout(() => spawnVisualOrbs(500), 600);
  }
}

// === MUSIC LOOP ===
function musicStep() {
  step = (step + 1) % 16;
  const pattern = [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0];
  if (pattern[step]) {
    const orb = musicOrbs[Math.floor(Math.random() * musicOrbs.length)];
    playOrbNote(orb);
  }
  musicOrbs.forEach(o => o.pulse *= 0.9);
}

// === SPACE BACKGROUND ===
function initSpace() {
  stars = [];
  for (let i = 0; i < 300; i++) {
    stars.push({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: Math.random() * 1.5,
      twinkle: Math.random() * Math.PI * 2
    });
  }
  nebula = [];
  for (let i = 0; i < 8; i++) {
    nebula.push({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      r: 200 + Math.random() * 300,
      color: ['#4a148c','#6a1b9a','#7b1fa2','#8e24aa'][Math.floor(Math.random()*4)]
    });
  }
}

function drawSpace() {
  nebula.forEach(n => {
    const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
    gradient.addColorStop(0, n.color + '22');
    gradient.addColorStop(1, n.color + '00');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
    ctx.fill();
  });
  stars.forEach(s => {
    const twinkle = Math.sin(Date.now() * 0.001 + s.twinkle) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  });
}

// === DRAW ORB ===
function drawOrb(orb) {
  const gradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.r * (1 + orb.pulse));
  gradient.addColorStop(0, orb.color);
  gradient.addColorStop(0.7, orb.color + '99');
  gradient.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(orb.x, orb.y, orb.r * (1 + orb.pulse), 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 80 + orb.pulse * 180;
  ctx.shadowColor = orb.color;
  ctx.fill();
  ctx.shadowBlur = 0;
}

// === ANIMATION LOOP ===
function animate() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.06)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawSpace();
  visualOrbs.forEach(orb => {
    orb.vx += (Math.random() - 0.5) * 0.3;
    orb.vy += (Math.random() - 0.5) * 0.3;
    orb.vx *= 0.99;
    orb.vy *= 0.99;
    orb.x += orb.vx;
    orb.y += orb.vy;
    orb.pulse *= 0.9;
    if (orb.x < orb.r) { orb.x = orb.r; orb.vx *= -0.7; }
    if (orb.x > innerWidth - orb.r) { orb.x = innerWidth - orb.r; orb.vx *= -0.7; }
    if (orb.y < orb.r) { orb.y = orb.r; orb.vy *= -0.7; }
    if (orb.y > innerHeight - orb.r) { orb.y = innerHeight - orb.r; orb.vy *= -0.7; }
  });
  checkVisualCollisions();
  visualOrbs.forEach(drawOrb);
  musicOrbs.forEach(drawOrb);
  animationId = requestAnimationFrame(animate);
}

// === START / PAUSE ===
async function start() {
  if (isPlaying) return;
  await initAudio();
  initSpace();
  spawnVisualOrbs(500);
  spawnMusicOrbs();
  musicInterval = setInterval(musicStep, 400);
  animate();
  isPlaying = true;
}

function pause() {
  if (!isPlaying) return;
  clearInterval(musicInterval);
  if (animationId) cancelAnimationFrame(animationId);
  isPlaying = false;
}

// === AUTO-START AFTER UNLOCK ===
window.addEventListener('load', () => {
  const check = setInterval(() => {
    if (window.top && window.top.audioUnlocked) {
      clearInterval(check);
      start();
    }
  }, 100);
});
</script>

</body>
</html>